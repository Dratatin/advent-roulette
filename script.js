// Advent Calendar Roulette Application
(function () {
  "use strict";

  // Configuration
  // Password hash will be loaded from Supabase
  let PASSWORD_HASH = null;
  const TOTAL_NUMBERS = 24;
  const STORAGE_KEY = "adventRouletteState";
  const AUTH_KEY = "adventRouletteAuth";
  const ADVENT_START_DAY = 1; // December 1st
  const ADVENT_START_MONTH = 11; // December (0-indexed)

  // TEST MODE: Set to true to bypass date restrictions (for testing purposes)
  // In test mode: no date verification, can draw multiple times per day
  const TEST_MODE = false; // Change to true to enable test mode

  // Supabase Configuration - Loaded from config.js (generated by GitHub Actions)
  const SUPABASE_URL = window.CONFIG?.SUPABASE_URL || "";
  const SUPABASE_ANON_KEY = window.CONFIG?.SUPABASE_ANON_KEY || "";

  // Descriptions cache (will be loaded from Supabase)
  let DESCRIPTIONS = {};

  // State
  let state = {
    remainingNumbers: [],
    history: [],
    lastDrawDate: null,
  };

  let timerInterval = null;

  // DOM Elements
  const rouletteDisplay = document.getElementById("rouletteDisplay");
  const spinButton = document.getElementById("spinButton");
  const message = document.getElementById("message");
  const numbersGrid = document.getElementById("numbersGrid");
  const historyList = document.getElementById("historyList");
  const resetButton = document.getElementById("resetButton");
  const descriptionDisplay = document.getElementById("descriptionDisplay");

  // Simple SHA-256 hash function
  async function hashPassword(password) {
    const msgBuffer = new TextEncoder().encode(password);
    const hashBuffer = await crypto.subtle.digest("SHA-256", msgBuffer);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray
      .map((b) => b.toString(16).padStart(2, "0"))
      .join("");
    return hashHex;
  }

  // Fetch password hash from Supabase
  async function fetchPasswordHash() {
    try {
      const response = await fetch(
        `${SUPABASE_URL}/rest/v1/config?select=password_hash&key=eq.main`,
        {
          headers: {
            apikey: SUPABASE_ANON_KEY,
            Authorization: `Bearer ${SUPABASE_ANON_KEY}`,
          },
        }
      );

      if (!response.ok) {
        throw new Error("Failed to fetch password hash");
      }

      const data = await response.json();

      if (data && data.length > 0 && data[0].password_hash) {
        PASSWORD_HASH = data[0].password_hash;
        return true;
      }

      throw new Error("Password hash not found");
    } catch (error) {
      console.error("Error fetching password hash:", error);
      alert("Erreur lors du chargement de la configuration.");
      return false;
    }
  }

  // Fetch descriptions from Supabase
  async function fetchDescriptions() {
    try {
      const response = await fetch(
        `${SUPABASE_URL}/rest/v1/advent_descriptions?select=*&order=day.asc`,
        {
          headers: {
            apikey: SUPABASE_ANON_KEY,
            Authorization: `Bearer ${SUPABASE_ANON_KEY}`,
          },
        }
      );

      if (!response.ok) {
        throw new Error("Failed to fetch descriptions");
      }

      const data = await response.json();

      // Convert array to object with day as key
      DESCRIPTIONS = {};
      data.forEach((item) => {
        DESCRIPTIONS[item.day] = item.description;
      });

      return true;
    } catch (error) {
      console.error("Error fetching descriptions:", error);
      alert("Erreur lors du chargement des descriptions. Veuillez r√©essayer.");
      return false;
    }
  }

  // Check authentication
  async function checkAuth() {
    const authSession = sessionStorage.getItem(AUTH_KEY);
    if (authSession === PASSWORD_HASH) {
      return true;
    }

    const enteredPassword = prompt("‚ö°Le moooot de passe ? (Harry-Potter)");

    if (enteredPassword === null) {
      document.body.innerHTML =
        '<div style="text-align:center;padding:50px;color:#fff;"><h1>Acc√®s Refus√©</h1><p>Mot de passe requis pour acc√©der √† cette page.</p></div>';
      return false;
    }

    const hashedInput = await hashPassword(enteredPassword);

    if (hashedInput === PASSWORD_HASH) {
      sessionStorage.setItem(AUTH_KEY, PASSWORD_HASH);
      return true;
    } else {
      alert("Mot de passe incorrect !");
      return checkAuth(); // Retry
    }
  }

  // Check if we are in the advent period (December 1-24)
  function isAdventPeriod() {
    if (TEST_MODE) return true; // Bypass date check in test mode

    const now = new Date();
    const month = now.getMonth();
    const day = now.getDate();

    return month === ADVENT_START_MONTH && day >= ADVENT_START_DAY && day <= 24;
  }

  // Check if advent has started
  function hasAdventStarted() {
    if (TEST_MODE) return true; // Bypass date check in test mode

    const now = new Date();
    const adventStart = new Date(
      now.getFullYear(),
      ADVENT_START_MONTH,
      ADVENT_START_DAY
    );
    return now >= adventStart;
  }

  // Get time until next draw (midnight or advent start)
  function getTimeUntilNextDraw() {
    const now = new Date();

    if (!hasAdventStarted()) {
      // Time until December 1st
      const adventStart = new Date(
        now.getFullYear(),
        ADVENT_START_MONTH,
        ADVENT_START_DAY
      );
      if (adventStart < now) {
        adventStart.setFullYear(adventStart.getFullYear() + 1);
      }
      return adventStart - now;
    }

    if (!isAdventPeriod()) {
      // Advent period is over
      return -1;
    }

    // Time until next midnight (when a new draw becomes available)
    const tomorrow = new Date(now);
    tomorrow.setDate(tomorrow.getDate() + 1);
    tomorrow.setHours(0, 0, 0, 0);
    return tomorrow - now;
  }

  // Format countdown timer
  function formatCountdown(milliseconds) {
    if (milliseconds < 0) return "";

    const hours = Math.floor(milliseconds / (1000 * 60 * 60));
    const minutes = Math.floor((milliseconds % (1000 * 60 * 60)) / (1000 * 60));
    const seconds = Math.floor((milliseconds % (1000 * 60)) / 1000);

    return `${hours}h ${minutes}m ${seconds}s`;
  }

  // Update timer display
  function updateTimer() {
    const timeLeft = getTimeUntilNextDraw();

    if (timeLeft < 0) {
      message.textContent = "üéÑ Noyeux Jo√´l ! üéÑ";
      spinButton.disabled = true;
      if (timerInterval) {
        clearInterval(timerInterval);
      }
      return;
    }

    if (!hasAdventStarted()) {
      message.textContent = `‚è∞ Bient√¥t bient√¥√¥√¥√¥t ${formatCountdown(
        timeLeft
      )}`;
      spinButton.disabled = true;
    } else if (hasReachedDrawLimit()) {
      const now = new Date();
      const currentDay = now.getDate();
      const currentDrawCount = state.history.length;
      
      if (currentDrawCount >= currentDay) {
        message.textContent = `‚è∞ Prochain tirage dans : ${formatCountdown(
          timeLeft
        )}`;
        spinButton.disabled = true;
      }
    }
  }

  // Start countdown timer
  function startTimer() {
    if (timerInterval) {
      clearInterval(timerInterval);
    }

    updateTimer();
    timerInterval = setInterval(updateTimer, 1000);
  }

  // Initialize the application
  async function init() {
    // Load password hash first (before authentication)
    const hashLoaded = await fetchPasswordHash();

    if (!hashLoaded) {
      document.body.innerHTML =
        '<div style="text-align:center;padding:50px;color:#fff;"><h1>Erreur</h1><p>Impossible de charger la configuration. Rechargez la page.</p></div>';
      return;
    }

    if (!(await checkAuth())) {
      return;
    }

    // Show loading message
    message.textContent = "‚è≥ Chargement des descriptions...";
    spinButton.disabled = true;

    // Load descriptions from Supabase
    const descriptionsLoaded = await fetchDescriptions();

    if (!descriptionsLoaded) {
      message.textContent = "‚ùå Erreur de chargement. Rechargez la page.";
      return;
    }

    loadState();
    renderNumbers();
    renderHistory();
    updateButtonState();
    startTimer();
  }

  // Load state from localStorage
  function loadState() {
    const savedState = localStorage.getItem(STORAGE_KEY);
    if (savedState) {
      try {
        state = JSON.parse(savedState);
      } catch (e) {
        resetState();
      }
    } else {
      resetState();
    }
  }

  // Save state to localStorage
  function saveState() {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
  }

  // Reset state to initial values
  function resetState() {
    state = {
      remainingNumbers: Array.from({ length: TOTAL_NUMBERS }, (_, i) => i + 1),
      history: [],
      lastDrawDate: null,
    };
    saveState();
  }

  // Get today's date as a string (YYYY-MM-DD)
  function getTodayString() {
    const today = new Date();
    const year = today.getFullYear();
    const month = String(today.getMonth() + 1).padStart(2, '0');
    const day = String(today.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  }

  // Check if we've reached the maximum allowed draws for the current date
  function hasReachedDrawLimit() {
    if (TEST_MODE) return false; // Allow unlimited draws in test mode

    if (!isAdventPeriod()) return true;

    const now = new Date();
    const currentDay = now.getDate();
    
    // Maximum draws allowed = current day of December
    // (e.g., on Dec 5th, you can have drawn up to 5 numbers)
    const maxAllowedDraws = currentDay;
    const currentDrawCount = state.history.length;

    return currentDrawCount >= maxAllowedDraws;
  }

  // Update button state based on current conditions
  function updateButtonState() {
    if (TEST_MODE) {
      // Show test mode indicator
      const testIndicator = "üß™ MODE TEST | ";
      if (state.remainingNumbers.length === 0) {
        spinButton.disabled = true;
        message.textContent = testIndicator + "üéâ C'est fini :(";
      } else {
        spinButton.disabled = false;
        message.textContent =
          testIndicator + `${state.remainingNumbers.length} num√©ros restants.`;
      }
      if (timerInterval) {
        clearInterval(timerInterval);
      }
      return;
    }

    if (!isAdventPeriod()) {
      spinButton.disabled = true;
      if (!hasAdventStarted()) {
        message.textContent =
          "‚è∞ Le calendrier de l'avent commence bient√¥t hop hop !";
      } else {
        message.textContent = "üéÑ Noyeux Jo√´l ! üéÑ";
      }
    } else if (state.remainingNumbers.length === 0) {
      spinButton.disabled = true;
      message.textContent = "üéâ C'est fini :(";
      if (timerInterval) {
        clearInterval(timerInterval);
      }
    } else if (hasReachedDrawLimit()) {
      spinButton.disabled = true;
      startTimer();
    } else {
      spinButton.disabled = false;
      const now = new Date();
      const currentDay = now.getDate();
      const currentDrawCount = state.history.length;
      const drawsRemaining = currentDay - currentDrawCount;
      
      message.textContent = `${state.remainingNumbers.length} num√©ros restants. Tu peux tirer ${drawsRemaining} fois aujourd'hui.`;
      if (timerInterval) {
        clearInterval(timerInterval);
      }
    }
  }

  // Render the numbers grid
  function renderNumbers() {
    numbersGrid.innerHTML = "";
    for (let i = 1; i <= TOTAL_NUMBERS; i++) {
      const cell = document.createElement("div");
      cell.className = "number-cell";
      cell.textContent = i;
      if (!state.remainingNumbers.includes(i)) {
        cell.classList.add("drawn");
        cell.title = DESCRIPTIONS[i]; // Show description on hover for drawn numbers
      }
      numbersGrid.appendChild(cell);
    }
  }

  // Render the history list
  function renderHistory() {
    const historySection = document.getElementById("historySection");

    historyList.innerHTML = "";

    // Hide history section if no draws yet
    if (state.history.length === 0) {
      historySection.style.display = "none";
      return;
    }

    historySection.style.display = "block";

    // Show history in reverse chronological order
    const reversedHistory = [...state.history].reverse();
    reversedHistory.forEach((item) => {
      const li = document.createElement("li");
      li.innerHTML = `
                <span class="date">${formatDate(item.date)}</span>
                <span class="number">${item.number}</span>
                <span class="description">${DESCRIPTIONS[item.number]}</span>
            `;
      historyList.appendChild(li);
    });
  }

  // Format date for display
  function formatDate(dateString) {
    const date = new Date(dateString);
    return date.toLocaleDateString("fr-FR", {
      weekday: "short",
      month: "short",
      day: "numeric",
    });
  }

  // Spin animation using setTimeout for proper slowdown effect
  function animateSpin(callback) {
    const duration = 2000;
    let elapsed = 0;
    let currentInterval = 50;

    rouletteDisplay.classList.add("spinning");

    function step() {
      elapsed += currentInterval;
      // Show random number during spin
      const randomIndex = Math.floor(
        Math.random() * state.remainingNumbers.length
      );
      rouletteDisplay.textContent = state.remainingNumbers[randomIndex];

      if (elapsed >= duration) {
        rouletteDisplay.classList.remove("spinning");
        callback();
        return;
      }

      // Slow down towards the end
      if (elapsed > duration * 0.7) {
        currentInterval += 20;
      }

      setTimeout(step, currentInterval);
    }

    step();
  }

  // Draw a number
  function drawNumber() {
    if (
      !isAdventPeriod() ||
      state.remainingNumbers.length === 0 ||
      hasReachedDrawLimit()
    ) {
      return;
    }

    // Disable button during animation
    spinButton.disabled = true;
    message.textContent = "üé∞ Tirage en cours...";
    descriptionDisplay.textContent = "";
    descriptionDisplay.classList.remove("visible");

    animateSpin(() => {
      // Select random number
      const randomIndex = Math.floor(
        Math.random() * state.remainingNumbers.length
      );
      const drawnNumber = state.remainingNumbers[randomIndex];

      // Update state
      state.remainingNumbers = state.remainingNumbers.filter(
        (n) => n !== drawnNumber
      );
      state.history.push({
        number: drawnNumber,
        date: getTodayString(),
      });
      // Note: lastDrawDate is kept for backward compatibility but no longer used for logic
      state.lastDrawDate = getTodayString();

      // Save and update UI
      saveState();
      rouletteDisplay.textContent = drawnNumber;
      renderNumbers();
      renderHistory();
      updateButtonState();

      message.textContent = `üéâ Le num√©ro du jour est : ${drawnNumber} !`;

      // Launch confetti effect
      createConfetti();

      // Show description with animation
      setTimeout(() => {
        descriptionDisplay.textContent = DESCRIPTIONS[drawnNumber];
        descriptionDisplay.classList.add("visible");
      }, 300);
    });
  }

  // Reset the calendar (requires password)
  async function resetCalendar() {
    const enteredPassword = prompt(
      "Entrez le mot de passe pour r√©initialiser le calendrier :"
    );

    if (enteredPassword === null) {
      return; // User cancelled
    }

    const hashedInput = await hashPassword(enteredPassword);

    if (hashedInput === PASSWORD_HASH) {
      if (
        confirm(
          "√ätes-vous s√ªr de vouloir r√©initialiser le calendrier ? Toute la progression sera perdue."
        )
      ) {
        resetState();
        rouletteDisplay.textContent = "?";
        renderNumbers();
        renderHistory();
        updateButtonState();
        alert("Le calendrier a √©t√© r√©initialis√© !");
      }
    } else {
      alert("Mot de passe incorrect !");
    }
  }

  // Event listeners
  spinButton.addEventListener("click", drawNumber);
  resetButton.addEventListener("click", resetCalendar);

  // Initialize when DOM is ready
  init();

  // Cleanup on page unload
  window.addEventListener("beforeunload", () => {
    if (timerInterval) {
      clearInterval(timerInterval);
    }
  });

  // Confetti effect
  function createConfetti() {
    const colors = [
      "#ff0000",
      "#00ff00",
      "#0000ff",
      "#ffff00",
      "#ff00ff",
      "#00ffff",
      "#ffd700",
      "#ff69b4",
    ];
    const confettiCount = 100;

    for (let i = 0; i < confettiCount; i++) {
      const confetti = document.createElement("div");
      confetti.style.position = "fixed";
      confetti.style.width = "10px";
      confetti.style.height = "10px";
      confetti.style.backgroundColor =
        colors[Math.floor(Math.random() * colors.length)];
      confetti.style.left = Math.random() * 100 + "%";
      confetti.style.top = "-10px";
      confetti.style.opacity = "1";
      confetti.style.transform = `rotate(${Math.random() * 360}deg)`;
      confetti.style.pointerEvents = "none";
      confetti.style.zIndex = "9999";
      confetti.style.borderRadius = "50%";

      document.body.appendChild(confetti);

      const duration = 3000 + Math.random() * 2000;
      const startTime = Date.now();
      const initialLeft = parseFloat(confetti.style.left);
      const drift = (Math.random() - 0.5) * 30;

      function animate() {
        const elapsed = Date.now() - startTime;
        const progress = elapsed / duration;

        if (progress < 1) {
          confetti.style.top = progress * 100 + "vh";
          confetti.style.left =
            initialLeft + drift * Math.sin(progress * Math.PI * 2) + "%";
          confetti.style.opacity = 1 - progress;
          confetti.style.transform = `rotate(${progress * 720}deg)`;
          requestAnimationFrame(animate);
        } else {
          confetti.remove();
        }
      }

      requestAnimationFrame(animate);
    }
  }
})();
